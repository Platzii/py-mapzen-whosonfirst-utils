#!/usr/bin/env python

import sys
import logging
import os.path
import csv
import pprint
import geojson

if __name__ == '__main__':

    import optparse
    opt_parser = optparse.OptionParser()

    opt_parser.add_option('-s', '--source', dest='source', action='store', default=None, help='Where to read files from')
    opt_parser.add_option('-a', '--abspath', dest='abspath', action='store_true', default=False, help='CSV file uses absolute paths (default is false)')
    opt_parser.add_option('-c', '--csv', dest='csv', action='store', default=None, help='CSV file to read')

    opt_parser.add_option('-o', '--out', dest='out', action='store', default=None, help='Where to write feature collection (default is STDOUT)')

    opt_parser.add_option('-v', '--verbose', dest='verbose', action='store_true', default=False, help='Be chatty (default is false)')
    options, args = opt_parser.parse_args()

    if options.verbose:	
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    if options.out:
        out = os.path.abspath(options.out)
        out = open(out, 'w')
    else:
        out = sys.stdout

    out.write("""{"type": "FeatureCollection", "features": [""")

    path = os.path.abspath(options.csv)
    fh = open(path, 'r')

    reader = csv.DictReader(fh)
    first = True

    # TO DO: max records...

    for row in reader:

        path = row['path']

        if not options.abspath:
            path = os.path.join(options.source, path)

        if not os.path.exists(path):
            logging.error("%s does not exist, skipping" % path)
            continue

        fh2 = open(path, 'r')

        if first == True:
            first = False
        else:
            out.write(",")

        out.write(fh2.read())

    out.write("""]}""")
    out.close()
