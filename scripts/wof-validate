#!/usr/bin/env python
# -*-python-*-

import sys
import os.path
import logging
import geojson
import types

import mapzen.whosonfirst.utils
import mapzen.whosonfirst.export
import mapzen.whosonfirst.placetypes

if __name__ == '__main__': 

    import optparse

    opt_parser = optparse.OptionParser("""wof-validate --options /path/to/wof-data""")

    opt_parser.add_option('--update', dest='update', action='store_true', default=False, help='Try to fix errant values (default is False)')
    opt_parser.add_option('--derive', dest='derive', action='store_true', default=False, help='Try to derive missing values (default is False)')

    opt_parser.add_option('--verbose', dest='verbose', action='store_true', default=False, help='Be chatty (default is false)')

    options, args = opt_parser.parse_args()

    if options.verbose:	
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    for source in args:

        source = os.path.abspath(source)

        exporter = mapzen.whosonfirst.export.flatfile(source)
        crawl = mapzen.whosonfirst.utils.crawl(source)

        for path in crawl:

            try:
                fh = open(path, 'r')
                feature = geojson.load(fh)
            except Exception, e:
                logging.error("failed to open %s because %s" % (path, e))
                continue

            props = feature['properties']

            required = {
                'wof:id': types.IntType,
                'wof:parent_id': types.IntType,
                'wof:name': types.UnicodeType,
                'wof:placetype': types.UnicodeType,
                'wof:concordances': types.DictType,
                'wof:hierarchy': types.ListType,
                'wof:belongsto': types.ListType,
                # 'geom:area': types.FloatType,
                # 'geom:latitude': types.FloatType,
                # 'geom:longitude': types.FloatType,
            }
            
            # ensure keys

            for k, ignore in required.items():

                if props.has_key(k):
                    logging.debug("%s has key (%s)" % (path, k))
                    continue

                if not options.update:
                    logging.warning("%s is missing key %s" % (path, k))
                    continue

                updated = False

                if k == 'wof:parent_id':
                    props['wof:parent_id'] = 1
                    updated = True

                elif k == 'wof:concordances':
                    props['wof:concordances'] = {}
                    updated = True

                elif k == 'wof:hierarchy':
                    props['wof:hierarchy'] = [] 
                    updated = True

                elif k == 'wof:belongsto':
                    props['wof:belongsto'] = [] 
                    updated = True

                else:
                    pass

                if updated:
                    feature['properties'] = props
                    exporter.export_feature(feature)
                    continue

                logging.warning("%s is missing key %s and I don't know what to do about it" % (path, k))

            # ensure expected types (for values)

            for k, expected in required.items():

                v = props[k]
                isa = type(v)

                if isa == expected:
                    logging.debug("%s has key (%s) with expected value (%s)" % (path, k, isa))
                    continue

                if not options.update:
                    logging.warning("%s has incorrect value for %s, expected %s but got %s" % (path, k, expected, isa))
                    continue

                updated = False

                if k == 'wof:hierarchy':

                    if isa == types.DictType:
                        props['wof:hierarchy'] = [ v]
                        updated = True

                elif k == 'wof:parent_id':

                    if isa == types.NoneType:
                        props['wof:parent_id'] = -1
                        updated = True

                    elif isa == types.UnicodeType:
                        props['wof:parent_id'] = int(v)
                        updated = True

                    else:
                        pass

                elif k == 'wof:name':
                    props['wof:name'] = u""
                    updated = True

                else:
                    pass
                
                if updated:
                    feature['properties'] = props
                    exporter.export_feature(feature)
                    continue

                logging.warning("%s has incorrect value for %s, expected %s but got %s, and I don't know what to do about it" % (path, k, expected, isa))        

        if not options.derive:
            continue

        # try to derive values from existing data or services

        updated = False

        hier = props.get('wof:hierarchy', [])
        count_hiers = len(hier)

        if count_hiers == 0:
            logging.warning("%s has a zero length hierarchy" % path)

        # check parent_id

        parent_id = props.get('wof:parent_id', -1)

        if parent_id == -1:

            if count_hiers == 1:
                logging.warning("%s has no parent but a single hierarchy so figure it out" % path)

        # check wof:name

        name = props.get("wof:name", "")

        if len(name) == 0:
            logging.warning("% has a zero-length name" % path)
