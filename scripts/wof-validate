#!/usr/bin/env python
# -*-python-*-

import sys
import os.path
import logging
import json
import geojson
import types

import requests
import shapely.geometry

import mapzen.whosonfirst.utils
import mapzen.whosonfirst.export
import mapzen.whosonfirst.placetypes

if __name__ == '__main__': 

    import optparse

    opt_parser = optparse.OptionParser("""wof-validate --options /path/to/wof-data""")

    opt_parser.add_option('--update', dest='update', action='store_true', default=False, help='Try to fix errant values (default is False)')
    opt_parser.add_option('--derive', dest='derive', action='store_true', default=False, help='Try to derive missing values (default is False)')

    opt_parser.add_option('--verbose', dest='verbose', action='store_true', default=False, help='Be chatty (default is false)')

    options, args = opt_parser.parse_args()

    if options.verbose:	
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    for source in args:

        source = os.path.abspath(source)

        exporter = mapzen.whosonfirst.export.flatfile(source)
        crawl = mapzen.whosonfirst.utils.crawl(source)

        for path in crawl:

            try:
                fh = open(path, 'r')
                feature = geojson.load(fh)
            except Exception, e:
                logging.error("failed to open %s because %s" % (path, e))
                continue

            props = feature['properties']

            required = {
                'wof:id': types.IntType,
                'wof:parent_id': types.IntType,
                'wof:name': types.UnicodeType,
                'wof:placetype': types.UnicodeType,
                'iso:country': types.UnicodeType,
                'wof:concordances': types.DictType,
                'wof:hierarchy': types.ListType,
                'wof:belongsto': types.ListType,
                'wof:supersedes': types.ListType,
                'wof:superseded_by': types.ListType,
                'wof:breaches': types.ListType,
                # 'geom:area': types.FloatType,
                # 'geom:latitude': types.FloatType,
                # 'geom:longitude': types.FloatType,
            }
            
            # ensure keys

            for k, ignore in required.items():

                if props.has_key(k):
                    logging.debug("%s has key (%s)" % (path, k))
                    continue

                logging.warning("%s is missing key %s" % (path, k))

                updated = False

                if k == 'wof:parent_id':
                    logging.info("assigning parent_id as -1")
                    props['wof:parent_id'] = -1
                    updated = True

                elif k == 'iso:country':
                    logging.info("assigning empty iso:country")
                    props['iso:country'] = ""
                    updated = True

                elif k == 'wof:concordances':
                    logging.info("assigning empty concordances")
                    props['wof:concordances'] = {}
                    updated = True

                elif k == 'wof:hierarchy':
                    logging.info("assigning empty hierarchy")
                    props['wof:hierarchy'] = [] 
                    updated = True

                elif k == 'wof:belongsto':
                    logging.info("assigning empty belongsto")
                    props['wof:belongsto'] = [] 
                    updated = True

                elif k == 'wof:supersedes':
                    logging.info("assigning empty supersedes")
                    props['wof:supersedes'] = [] 
                    updated = True

                elif k == 'wof:superseded_by':
                    logging.info("assigning empty superseded_by")
                    props['wof:superseded_by'] = [] 
                    updated = True

                else:
                    pass

                if updated and options.update:
                    feature['properties'] = props
                    exporter.export_feature(feature)

            # ensure expected types (for values)

            for k, expected in required.items():

                v = props[k]
                isa = type(v)

                if isa == expected:
                    logging.debug("%s has key (%s) with expected value (%s)" % (path, k, isa))
                    continue

                logging.warning("%s has incorrect value for %s, expected %s but got %s" % (path, k, expected, isa))

                updated = False

                if k == 'wof:hierarchy':

                    if isa == types.DictType:
                        props['wof:hierarchy'] = [ v]
                        updated = True

                elif k == 'wof:parent_id':

                    if isa == types.NoneType:
                        props['wof:parent_id'] = -1
                        updated = True

                    elif isa == types.UnicodeType:
                        props['wof:parent_id'] = int(v)
                        updated = True

                    else:
                        pass

                elif k == 'iso:country':

                    if isa == types.StringType:
                        props['iso:country'] = unicode(v)
                        updated = True

                elif k == 'wof:name':
                    props['wof:name'] = u""
                    updated = True

                else:
                    pass
                
                if updated and options.update:
                    feature['properties'] = props
                    exporter.export_feature(feature)
            
            if not options.derive:
                continue

            # try to derive values from existing data or services
        
            updated = False

            hier = props.get('wof:hierarchy', [])
            count_hiers = len(hier)
            
            if count_hiers == 0:
                logging.warning("%s has a zero length hierarchy" % path)

                hier = mapzen.whosonfirst.utils.generate_hierarchy(feature)
                print hier
                sys.exit()

            # check parent_id

            parent_id = props.get('wof:parent_id', -1)
            
            if parent_id == -1:
                
                if count_hiers == 1:

                    placetype = props['wof:placetype']
                    placetype = mapzen.whosonfirst.placetypes.placetype(placetype)
                      
                    new_parent_id = None
                      
                    # sudo make me recurse up through ancestors?

                    for pt in placetype.parents():
                      
                      	parent_id_key = "%s_id" % pt
                        new_parent_id = hier[0].get(parent_id_key, None)

                        if new_parent_id:
                            break

                    if new_parent_id and new_parent_id != -1:
                        logging.info("%s has -1 parent id and setting to %s" % (path, new_parent_id))
                        props['wof:parent_id'] = new_parent_id
                        updated = True
                    else:
                        logging.warning("%s has no parent and a single hierarchy but unable to figure it out..." % path)

            else:
                pass

            """
            if parent_id == -1:

                lat = None
                lon = None

                if props.get('geom:latitude', False) and props.get('geom:longitude', False):
                    lat = props['geom:latitude']
                    lon = props['geom:longitude']
                else:

                    geom = feature['geometry']
                    shp = shapely.geometry.asShape(geom)
                    coords = shp.centroid
                    lat = coords.y
                    lon = coords.x

                placetype = props['wof:placetype']
                placetype = mapzen.whosonfirst.placetypes.placetype(placetype)

                placetypes = []

                for pt in placetype.parents():
                    placetypes.append(str(pt))

                placetypes = ",".join(placetypes)

                try:
                    params = {'latitude': lat, 'longitude': lon, 'placetype': placetypes}
                    print params
                    rsp = requests.get('https://54.148.56.3/', params=params, verify=False)
                    rsp = json.loads(rsp.content)
                except Exception, e:
                    continue

                print rsp
                print "WHAT"
                sys.exit()
            """

            # figure if/whether to do a fresh point-in-polygon lookup

            # take this and move it in to utils
            # https://github.com/mapzen/py-mapzen-whosonfirst-import/blob/master/mapzen/whosonfirst/importer/__init__.py

            # check wof:name

            name = props.get("wof:name", "")

            if len(name) == 0:
                logging.debug("%s has a zero-length name" % path)

            # check ISO country

            iso = props.get("iso:country", "")

            if len(iso) != 2:
                logging.debug("%s has a weird ISO" % path)
                
            # update the record?

            if updated and options.update:
                feature['properties'] = props
                exporter.export_feature(feature)
